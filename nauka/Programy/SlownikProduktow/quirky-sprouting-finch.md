# Plan Nauki - ZAKTUALIZOWANY (17 Grudnia 2025)

## üéØ Tw√≥j Profil

**Start:** 17 Grudnia 2025 (ju≈º w trakcie!)
**Meta:** Wrzesie≈Ñ 2026 (9 miesiƒôcy)
**Dostƒôpny czas:**
- Dni robocze: 3-4.5h (w pracy 2-3h + po pracy 1-1.5h)
- **Weekendy:** max 1-2h/dzie≈Ñ (elastycznie!)
- **≈öwiƒôta:** odpoczynek lub je≈õli masz czas
**Cel:** Praca in≈ºynierska - System w chmurze Azure

**Specjalizacja:** Technologia Chmury Obliczeniowej
**Wymagania uczelni:** Azure (obowiƒÖzkowe)
**Dodatkowe bazy:** MSSQL, Azure SQL Database, Oracle (opcjonalnie)

**WA≈ªNE:** Plan jest elastyczny! Je≈õli w kt√≥rym≈õ tygodniu nie zdƒÖ≈ºysz - nic siƒô nie stanie. Masz wystarczajƒÖco du≈ºo czasu do wrze≈õnia. Priorytet: **jako≈õƒá > tempo**.

---

## üìä Tw√≥j Obecny Poziom (17 Grudnia 2025)

### ‚úÖ Co ju≈º umiesz:

**Python Podstawy:**
- [x] Zmienne, typy danych (int, float, str)
- [x] If-elif-else, while True, break
- [x] Listy (append, remove, sort, clear)
- [x] S≈Çowniki (zagnie≈ºd≈ºone struktury)
- [x] Pƒôtle for, enumerate(start=1)
- [x] Funkcje (def, return, docstringi)
- [x] Try-except (ValueError)
- [x] Walidacja danych (if value <= 0, if product in dict)
- [x] String manipulation (.lower(), .strip())
- [x] Obs≈Çuga plik√≥w (open, write, encoding="utf-8")
- [x] `if __name__ == "__main__":`
- [x] main() pattern

**Projekty uko≈Ñczone:**
1. ‚úÖ Lista zakup√≥w (lista_zakupow.py) - 118 linii
2. ‚úÖ S≈Çownik produkt√≥w (Slownik_produktow.py) - w trakcie rozwijania

**Oszacowany postƒôp:** Jeste≈õ w po≈Çowie Tygodnia 2 z oryginalnego planu!

---

### ‚ùå Czego jeszcze nie znasz:

- [ ] JSON (import json, dumps, loads)
- [ ] datetime (now, strftime, timedelta)
- [ ] List comprehensions
- [ ] Lambda functions
- [ ] Modu≈Çy (import w≈Çasnych plik√≥w)
- [ ] Excel (openpyxl, pandas)
- [ ] Klasy i OOP
- [ ] SQL (podstawy, JOIN-y, transakcje)
- [ ] pyodbc / sqlalchemy
- [ ] pandas (DataFrame)
- [ ] Tkinter (GUI)
- [ ] Azure (Cloud, SQL Database, Storage, Functions)

---

## üó∫Ô∏è NOWY Plan Nauki (Grudzie≈Ñ 2025 - Wrzesie≈Ñ 2026)

### R√≥≈ºnice od pierwotnego planu:

1. **Tempo przyspieszone:** 3-4.5h/dzie≈Ñ = 2-3√ó szybciej
2. **Wiƒôcej czasu na podstawy:** Dodatkowe 2 tygodnie na Python
3. **Focus na Azure:** Ca≈Ça Faza 6 po≈õwiƒôcona Azure
4. **SQL r√≥wnolegle:** Uczysz siƒô w pracy, wiƒôc szybciej przejdziesz teoriƒô
5. **Projekt ko≈Ñcowy:** System w Azure (nie lokalny SQL Server)

### Timeline:

```
Grudzie≈Ñ 2025:      Python Fundamenty (doko≈Ñczenie)    [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë]
Stycze≈Ñ 2026:       Python Zaawansowany + JSON/Excel   [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë]
Luty 2026:          SQL Server + Azure SQL Database    [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà]
Marzec 2026:        OOP + pyodbc + architektura         [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà]
Kwiecie≈Ñ 2026:      pandas + Excel + Azure Blob         [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë]
Maj 2026:           GUI Tkinter + integracja            [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë]
Czerwiec 2026:      Azure Cloud (Functions, App Service)[‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë]
Lipiec 2026:        Projekt fina≈Çowy w Azure            [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë]
Sierpie≈Ñ 2026:      Dokumentacja + optymalizacja        [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë]
Wrzesie≈Ñ 2026:      Obrona pracy in≈ºynierskiej          [‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë]
```

---

## üìÖ SZCZEG√ì≈ÅOWY PLAN MIESIƒòCZNY

---

## GRUDZIE≈É 2025 (17-31 Grudnia) - Python Fundamenty

**Status:** W TRAKCIE (Tydzie≈Ñ 2)
**Czas dostƒôpny:** 14 dni √ó 3.5h = 49 godzin

### Tydzie≈Ñ 2.5 (17-29 Grudnia): Doko≈Ñczenie S≈Çownika Produkt√≥w

**Cel:** Rozszerzyƒá s≈Çownik produkt√≥w o brakujƒÖce funkcje

**UWAGA:** 24-26 grudnia = ≈öwiƒôta (mniej czasu), weekendy = max 1-2h/dzie≈Ñ

**Zadania (13 dni z przerwami = ~35h):**

**Dzie≈Ñ 1-3 (17-19 Gru, wt-cz): Doko≈Ñczenie podstawowych funkcji** (~10h)
- [ ] Funkcja `edit_product()` - edycja ceny/ilo≈õci/kategorii
- [ ] Funkcja `show_products()` - ≈Çadne wy≈õwietlanie (JU≈ª ZACZƒÑ≈ÅE≈ö!)
- [ ] Funkcja `sort_products()` - sortowanie (WIDZƒò LAMBDA - DOBRZE!)
- [ ] Funkcja `filter_by_category()` - filtrowanie po kategorii
- [ ] Dodaj walidacjƒô do wszystkich funkcji

**Dzie≈Ñ 4-5 (20-21 Gru, pt-sob): Zaawansowane funkcje** (~5h - weekend!)
- [ ] Funkcja `find_max_price()` - produkt z najwy≈ºszƒÖ cenƒÖ
- [ ] Funkcja `find_min_price()` - produkt z najni≈ºszƒÖ cenƒÖ
- [ ] Funkcja `calculate_total_value()` - warto≈õƒá magazynu (cena √ó ilo≈õƒá)

**Dzie≈Ñ 6 (22 Gru, nd): Review** (~1h - weekend!)
- [ ] Testuj to co do tej pory
- [ ] Poprawki b≈Çƒôd√≥w

**Dzie≈Ñ 7-9 (23, 27-28 Gru): Przerwa + lekka praca** (~6h total)
- 23 Gru (pn): Normalna praca (~3h)
  - [ ] Funkcja `low_stock_alert()` - produkty o niskim stanie
- 24-26 Gru: ≈öWIƒòTA - odpoczynek lub max 1h/dzie≈Ñ je≈õli chcesz
- 27-28 Gru (pt-sob): Weekend (~3h)
  - [ ] Testowanie wszystkich funkcji
  - [ ] Dodaj wiƒôcej walidacji

**Dzie≈Ñ 10-13 (29 Gru - 1 Sty): Finalizacja** (~14h)
- [ ] Refactoring kodu
- [ ] Popraw komunikaty b≈Çƒôd√≥w (czytelne)
- [ ] Kod zgodny z PEP 8
- [ ] Dokumentacja funkcji (docstringi)
- [ ] Commit do GitHub

**Weryfikacja:**
- [ ] Program ma 10+ funkcji
- [ ] Wszystkie funkcje dzia≈ÇajƒÖ bez b≈Çƒôd√≥w
- [ ] Walidacja w ka≈ºdej funkcji
- [ ] Kod ~200 linii, czytelny i skomentowany

**Harmonogram elastyczny:** Je≈õli w ≈õwiƒôta nie zdƒÖ≈ºysz - nic siƒô nie stanie! Odrobisz w dni robocze (27-31 grudnia).

---

### Tydzie≈Ñ 3 (30 Gru - 5 Sty): JSON i datetime

**UWAGA:** 1 stycznia = Nowy Rok (odpoczynek), weekendy = max 1-2h

**Cel:** Nauczyƒá siƒô JSON i datetime

**Zadania (7 dni, elastyczne ~20h):**

**Dzie≈Ñ 1-2 (30-31 Gru, pn-wt): JSON - Podstawy** (~7h)
```python
import json

# Zapis s≈Çownika do JSON
with open("produkty.json", "w", encoding="utf-8") as f:
    json.dump(products, f, ensure_ascii=False, indent=4)

# Odczyt z JSON
with open("produkty.json", "r", encoding="utf-8") as f:
    products = json.load(f)
```

**Projekt:** Dodaj do s≈Çownika produkt√≥w:
- [ ] Funkcja `save_to_json()` - zapis do pliku JSON
- [ ] Funkcja `load_from_json()` - wczytanie z JSON
- [ ] Auto-load przy starcie programu (je≈õli plik istnieje)
- [ ] Auto-save przy wyj≈õciu

**Dzie≈Ñ 3 (1 Sty, ≈õr): ODPOCZYNEK** - Nowy Rok!

**Dzie≈Ñ 4-5 (2-3 Sty, cz-pt): datetime - Podstawy** (~7h)
```python
from datetime import datetime, timedelta

# Aktualna data i czas
teraz = datetime.now()
print(teraz.strftime("%Y-%m-%d %H:%M:%S"))

# Data za 7 dni
za_tydzien = teraz + timedelta(days=7)
```

**Projekt:** Rozszerz s≈Çownik produkt√≥w:
- [ ] Dodaj pole `data_dodania` do ka≈ºdego produktu
- [ ] Funkcja `show_recent_products(days=7)` - produkty dodane ostatnio
- [ ] Funkcja `product_age(product_name)` - ile dni temu dodano
- [ ] Logger: zapisuj wszystkie operacje z timestamp do `log.txt`

**Dzie≈Ñ 6-7 (4-5 Sty, sob-nd): Integracja JSON + datetime** (~3h - weekendy!)
- [ ] Zapisz produkty do JSON z datami (datetime ‚Üí string)
- [ ] Wczytaj z JSON i konwertuj stringi ‚Üí datetime
- [ ] Historia zmian: zapisuj edycje produkt√≥w z timestamp
- [ ] Raport: podsumowanie operacji za ostatni tydzie≈Ñ

**Podsumowanie Tygodnia 3:**
- [ ] Testuj zapis/odczyt JSON
- [ ] Testuj operacje z datami
- [ ] Kod czytelny, skomentowany

**Weryfikacja:**
- [ ] Potrafiƒô zapisaƒá/wczytaƒá JSON
- [ ] Potrafiƒô formatowaƒá daty (strftime)
- [ ] Rozumiem timedelta
- [ ] Program zachowuje dane miƒôdzy uruchomieniami

---

### Tydzie≈Ñ 4 (30-31 Grudnia + 1-5 Stycznia): List Comprehensions + Lambda

**Cel:** Zaawansowane techniki Python

**Zadania (7 dni √ó 3.5h = 24.5h):**

**Dzie≈Ñ 1-2: List Comprehensions**
```python
# Zamiast pƒôtli:
numbers = []
for i in range(10):
    if i % 2 == 0:
        numbers.append(i * 2)

# List comprehension:
numbers = [i * 2 for i in range(10) if i % 2 == 0]

# Dictionary comprehension:
squares = {x: x**2 for x in range(5)}
```

**ƒÜwiczenia:**
- [ ] 20 prostych list comprehensions
- [ ] Przepisz pƒôtle z istniejƒÖcych program√≥w
- [ ] Dictionary comprehensions
- [ ] Nested comprehensions (2D listy)

**Dzie≈Ñ 3-4: Lambda Functions**
```python
# Funkcja zwyk≈Ça:
def square(x):
    return x ** 2

# Lambda:
square = lambda x: x ** 2

# Z sorted():
products_sorted = sorted(products.items(),
                         key=lambda item: item[1]['cena'])
```

**ƒÜwiczenia:**
- [ ] Sortowanie s≈Çownika po r√≥≈ºnych kluczach (cena, ilo≈õƒá, nazwa)
- [ ] Filter + lambda (produkty dro≈ºsze ni≈º 100)
- [ ] Map + lambda (podwy≈ºka cen o 10%)

**Dzie≈Ñ 5-7: PROJEKT - System Biblioteki v1.0**

**Wymagania:**
- S≈Çownik ksiƒÖ≈ºek: `{tytu≈Ç: {autor, ISBN, rok, wypo≈ºyczone: bool, data_wypo≈ºyczenia}}`
- Funkcje:
  - [ ] Dodaj ksiƒÖ≈ºkƒô (z walidacjƒÖ)
  - [ ] Usu≈Ñ ksiƒÖ≈ºkƒô
  - [ ] Edytuj ksiƒÖ≈ºkƒô
  - [ ] Wypo≈ºycz ksiƒÖ≈ºkƒô (ustaw `wypo≈ºyczone=True`, zapisz datƒô)
  - [ ] Zwr√≥ƒá ksiƒÖ≈ºkƒô (ustaw `wypo≈ºyczone=False`)
  - [ ] Poka≈º dostƒôpne ksiƒÖ≈ºki (list comprehension!)
  - [ ] Poka≈º wypo≈ºyczone ksiƒÖ≈ºki
  - [ ] Raport: najstarsze ksiƒÖ≈ºki (sortowanie lambda)
  - [ ] Raport: ksiƒÖ≈ºki wypo≈ºyczone >30 dni (datetime)
  - [ ] Zapis/odczyt JSON
  - [ ] Logger operacji
- Try-except w ka≈ºdej funkcji
- Menu u≈ºytkownika
- ~300 linii kodu

**Weryfikacja ko≈Ñca Grudnia:**
- [ ] Potrafiƒô list comprehensions
- [ ] Potrafiƒô lambda functions
- [ ] System Biblioteki dzia≈Ça bez b≈Çƒôd√≥w
- [ ] JSON i datetime opanowane

---

## STYCZE≈É 2026 - Python Zaawansowany + Excel

**Cel:** Doko≈Ñczyƒá Python fundamenty, nauczyƒá siƒô Excel

**Czas dostƒôpny:** 31 dni √ó 3.5h = 108.5 godzin

### Tydzie≈Ñ 5 (6-12 Stycznia): Modu≈Çy i Struktura Projektu

**Cel:** Nauczyƒá siƒô organizowaƒá kod w wiele plik√≥w

**Dzie≈Ñ 1-3: Modu≈Çy w≈Çasne**

Struktura projektu:
```
moj_projekt/
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ utils.py          # Funkcje pomocnicze
‚îú‚îÄ‚îÄ validators.py     # Walidacje
‚îú‚îÄ‚îÄ file_handler.py   # JSON read/write
‚îî‚îÄ‚îÄ constants.py      # Sta≈Çe (np. nazwy plik√≥w)
```

**Przyk≈Çad:**
```python
# validators.py
def validate_price(price):
    if not isinstance(price, (int, float)):
        raise ValueError("Cena musi byƒá liczbƒÖ")
    if price <= 0:
        raise ValueError("Cena musi byƒá > 0")
    return True

# main.py
from validators import validate_price

price = float(input("Cena: "))
validate_price(price)
```

**Projekt:** Przepisz System Biblioteki na modu≈Çy:
- [ ] `main.py` - menu i g≈Ç√≥wna pƒôtla
- [ ] `book_manager.py` - operacje na ksiƒÖ≈ºkach
- [ ] `file_handler.py` - JSON read/write
- [ ] `validators.py` - wszystkie walidacje
- [ ] `utils.py` - formatowanie dat, string√≥w
- [ ] `config.py` - sta≈Çe (nazwy plik√≥w, limity)

**Dzie≈Ñ 4-7: Zaawansowane try-except**
- [ ] W≈Çasne wyjƒÖtki (custom exceptions)
- [ ] Try-except-else-finally
- [ ] Raising exceptions
- [ ] Context managers (with statement)
- [ ] Przepisz ca≈Çy kod z lepszƒÖ obs≈ÇugƒÖ b≈Çƒôd√≥w

**Weryfikacja:**
- [ ] Rozumiem import i modu≈Çy
- [ ] Projekt podzielony na pliki
- [ ] Obs≈Çuga b≈Çƒôd√≥w profesjonalna

---

### Tydzie≈Ñ 6 (13-19 Stycznia): Excel - openpyxl

**Cel:** Nauczyƒá siƒô czytaƒá i pisaƒá pliki Excel

**Dzie≈Ñ 1-2: Instalacja i podstawy**
```bash
pip install openpyxl
```

```python
from openpyxl import Workbook, load_workbook

# Tworzenie nowego pliku Excel
wb = Workbook()
ws = wb.active
ws.title = "Produkty"

# Nag≈Ç√≥wki
ws['A1'] = "Nazwa"
ws['B1'] = "Cena"
ws['C1'] = "Ilo≈õƒá"

# Dane
ws.append(["Laptop", 2500, 10])
ws.append(["Mysz", 45, 50])

# Zapis
wb.save("produkty.xlsx")

# Odczyt
wb = load_workbook("produkty.xlsx")
ws = wb.active
for row in ws.iter_rows(min_row=2, values_only=True):
    print(row)
```

**Dzie≈Ñ 3-4: Formatowanie**
- [ ] Szeroko≈õƒá kolumn (column_dimensions)
- [ ] Czcionki (Font)
- [ ] Kolory (PatternFill)
- [ ] Wyr√≥wnanie (Alignment)
- [ ] Obramowanie (Border)

**Dzie≈Ñ 5-7: PROJEKT - Eksport produkt√≥w do Excel**

**Wymagania:**
- [ ] Funkcja `export_to_excel(filename)`:
  - Nag≈Ç√≥wki: Nazwa, Cena, Ilo≈õƒá, Kategoria, Data dodania, Warto≈õƒá (cena√óilo≈õƒá)
  - Wszystkie produkty ze s≈Çownika
  - Formatowanie: nag≈Ç√≥wki pogrubione, kolory naprzemienne
  - Auto-width kolumn
  - SUM na ko≈Ñcu (suma warto≈õci)
- [ ] Funkcja `import_from_excel(filename)`:
  - Wczytaj produkty z Excel
  - Dodaj do s≈Çownika
  - Walidacja danych
- [ ] Menu: opcja "Eksportuj do Excel" i "Importuj z Excel"

**Weryfikacja:**
- [ ] Potrafiƒô tworzyƒá pliki Excel
- [ ] Potrafiƒô formatowaƒá kom√≥rki
- [ ] Eksport/import dzia≈Ça

---

### Tydzie≈Ñ 7 (20-26 Stycznia): Regular Expressions (Regex)

**Cel:** Walidacja zaawansowana (email, telefon, kody)

**Dzie≈Ñ 1-3: Podstawy regex**
```python
import re

# Wzorce
email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
phone_pattern = r'^\+48\s?\d{3}\s?\d{3}\s?\d{3}$'

# Walidacja
if re.match(email_pattern, "user@example.com"):
    print("Email poprawny")
```

**Dzie≈Ñ 4-7: PROJEKT - Walidatory**
- [ ] `validate_email(email)` - regex
- [ ] `validate_phone(phone)` - regex
- [ ] `validate_postal_code(code)` - regex (XX-XXX)
- [ ] `validate_ISBN(isbn)` - regex
- [ ] Dodaj do systemu biblioteki walidacjƒô ISBN
- [ ] Dodaj do s≈Çownika produkt√≥w walidacjƒô kod√≥w kreskowych

**Weryfikacja:**
- [ ] Rozumiem podstawy regex
- [ ] Potrafiƒô walidowaƒá stringi

---

### Tydzie≈Ñ 8 (27 Stycznia - 2 Lutego): PROJEKT MIESIƒÑCA

**Cel:** System ZarzƒÖdzania Sklepem v1.0 (Pure Python)

**Wymagania (7 dni √ó 4h = 28h):**

**Funkcjonalno≈õci:**
1. **ZarzƒÖdzanie produktami:**
   - Dodaj/usu≈Ñ/edytuj produkt
   - S≈Çownik: `{nazwa: {cena, ilo≈õƒá, kategoria, kod_kreskowy, data_dodania}}`
   - Walidacja: cena > 0, ilo≈õƒá >= 0, kod_kreskowy (regex)

2. **ZarzƒÖdzanie klientami:**
   - Dodaj/usu≈Ñ/edytuj klienta
   - S≈Çownik: `{email: {imiƒô, nazwisko, telefon, adres, data_rejestracji}}`
   - Walidacja: email (regex), telefon (regex)

3. **Zam√≥wienia:**
   - Z≈Ç√≥≈º zam√≥wienie (klient, lista produkt√≥w, ilo≈õci)
   - Lista: `[{id, klient_email, produkty: [{nazwa, ilo≈õƒá, cena}], data, warto≈õƒá_total}]`
   - Automatyczne zmniejszanie stanu magazynowego
   - Walidacja: czy produkt dostƒôpny, czy ilo≈õƒá wystarczajƒÖca

4. **Raporty:**
   - Produkty o niskim stanie (<5)
   - Top 5 najdro≈ºszych produkt√≥w (sorted + lambda)
   - Warto≈õƒá magazynu (sum + list comprehension)
   - Zam√≥wienia z ostatnich 7 dni (datetime)
   - Najlepsi klienci (najwiƒôcej zam√≥wie≈Ñ)

5. **Eksport/Import:**
   - Produkty ‚Üí Excel
   - Klienci ‚Üí Excel
   - Zam√≥wienia ‚Üí Excel
   - Wszystkie dane ‚Üí JSON (backup)
   - Wczytanie backup z JSON

6. **Logger:**
   - Wszystkie operacje zapisywane do `shop_log.txt` z timestamp
   - Format: `[2026-01-15 14:23:11] Dodano produkt: Laptop`

**Struktura plik√≥w:**
```
sklep/
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ product_manager.py
‚îú‚îÄ‚îÄ customer_manager.py
‚îú‚îÄ‚îÄ order_manager.py
‚îú‚îÄ‚îÄ reports.py
‚îú‚îÄ‚îÄ file_handler.py     # JSON + Excel
‚îú‚îÄ‚îÄ validators.py
‚îú‚îÄ‚îÄ utils.py
‚îú‚îÄ‚îÄ constants.py
‚îî‚îÄ‚îÄ data/
    ‚îú‚îÄ‚îÄ products.json
    ‚îú‚îÄ‚îÄ customers.json
    ‚îú‚îÄ‚îÄ orders.json
    ‚îî‚îÄ‚îÄ shop_log.txt
```

**Wymagania techniczne:**
- Minimum 500 linii kodu
- Try-except w ka≈ºdej funkcji
- Docstringi dla wszystkich funkcji
- PEP 8 compliant
- Komentarze po polsku

**Weryfikacja ko≈Ñca Stycznia:**
- [ ] System sklepu w 100% funkcjonalny
- [ ] Wszystkie raporty dzia≈ÇajƒÖ
- [ ] Eksport do Excel dzia≈Ça
- [ ] JSON backup/restore dzia≈Ça
- [ ] Kod modularny i czysty
- [ ] **GOTOWY DO PREZENTACJI** (to bƒôdzie czƒô≈õƒá portfolio!)

---

## LUTY 2026 - SQL Server + Azure SQL Database

**Cel:** Nauczyƒá siƒô SQL (w pracy + po pracy)

**Czas:** 28 dni √ó 3.5h = 98 godzin

**Uwaga:** Masz SQL w pracy, wiƒôc teoria bƒôdzie szybsza!

### Tydzie≈Ñ 9 (3-9 Lutego): SQL Server - Instalacja i Podstawy

**W pracy (2h/dzie≈Ñ):**
- Instalacja SQL Server Express + SSMS
- Tworzenie bazy danych
- CREATE TABLE
- INSERT, SELECT, UPDATE, DELETE
- WHERE, ORDER BY

**Po pracy (1.5h/dzie≈Ñ):**
- Przepisywanie przyk≈Çad√≥w z pracy
- 50 prostych zapyta≈Ñ SELECT
- W≈Çasna baza "Kontakty"

**Projekt:** Baza danych kontakt√≥w
```sql
CREATE DATABASE KontaktyDB;

CREATE TABLE kontakty (
    id INT IDENTITY(1,1) PRIMARY KEY,
    imie NVARCHAR(100),
    nazwisko NVARCHAR(100),
    email NVARCHAR(255),
    telefon NVARCHAR(20),
    data_dodania DATETIME DEFAULT GETDATE()
);
```

**Weryfikacja:**
- [ ] SQL Server zainstalowany
- [ ] Potrafiƒô CREATE, INSERT, SELECT
- [ ] 50+ zapyta≈Ñ napisanych

---

### Tydzie≈Ñ 10 (10-16 Lutego): Typy Danych i Klucze Obce

**W pracy:**
- PRIMARY KEY, FOREIGN KEY
- IDENTITY (auto-increment)
- NVARCHAR vs VARCHAR
- DATETIME, DECIMAL
- Projektowanie schematu

**Po pracy:**
- Projektuj schemat bazy "Sklep"
- Diagramy ERD (Entity Relationship Diagram)

**Projekt:** Baza danych Sklep
```sql
CREATE TABLE klienci (
    id INT IDENTITY(1,1) PRIMARY KEY,
    email NVARCHAR(255) NOT NULL UNIQUE,
    imie NVARCHAR(100),
    nazwisko NVARCHAR(100),
    telefon NVARCHAR(20),
    adres NVARCHAR(500),
    data_rejestracji DATETIME DEFAULT GETDATE()
);

CREATE TABLE produkty (
    id INT IDENTITY(1,1) PRIMARY KEY,
    nazwa NVARCHAR(255) NOT NULL,
    cena DECIMAL(10,2) NOT NULL,
    ilosc INT DEFAULT 0,
    kategoria NVARCHAR(100),
    kod_kreskowy NVARCHAR(50),
    data_dodania DATETIME DEFAULT GETDATE()
);

CREATE TABLE zamowienia (
    id INT IDENTITY(1,1) PRIMARY KEY,
    klient_id INT NOT NULL,
    data_zamowienia DATETIME DEFAULT GETDATE(),
    wartosc_total DECIMAL(10,2),
    status NVARCHAR(50) DEFAULT 'nowe',
    FOREIGN KEY (klient_id) REFERENCES klienci(id)
);

CREATE TABLE pozycje_zamowien (
    id INT IDENTITY(1,1) PRIMARY KEY,
    zamowienie_id INT NOT NULL,
    produkt_id INT NOT NULL,
    ilosc INT NOT NULL,
    cena_jednostkowa DECIMAL(10,2) NOT NULL,
    FOREIGN KEY (zamowienie_id) REFERENCES zamowienia(id),
    FOREIGN KEY (produkt_id) REFERENCES produkty(id)
);
```

**Weryfikacja:**
- [ ] Rozumiem klucze obce
- [ ] Schemat bazy zaprojektowany

---

### Tydzie≈Ñ 11 (17-23 Lutego): Agregacje i GROUP BY

**W pracy:**
- COUNT, SUM, AVG, MIN, MAX
- GROUP BY, HAVING
- TOP N
- Subqueries

**Po pracy:**
- 30 zapyta≈Ñ z agregacjami
- Raporty z bazy Sklep

**Przyk≈Çady:**
```sql
-- Liczba produkt√≥w per kategoria
SELECT kategoria, COUNT(*) as liczba
FROM produkty
GROUP BY kategoria;

-- Top 5 klient√≥w (warto≈õƒá zam√≥wie≈Ñ)
SELECT TOP 5 k.imie, k.nazwisko, SUM(z.wartosc_total) as suma
FROM klienci k
JOIN zamowienia z ON k.id = z.klient_id
GROUP BY k.id, k.imie, k.nazwisko
ORDER BY suma DESC;

-- ≈örednia warto≈õƒá zam√≥wienia
SELECT AVG(wartosc_total) as srednia
FROM zamowienia;
```

**Weryfikacja:**
- [ ] Potrafiƒô COUNT, SUM, AVG
- [ ] Rozumiem GROUP BY

---

### Tydzie≈Ñ 12 (24 Lutego - 2 Marca): JOIN-y

**W pracy:**
- INNER JOIN
- LEFT JOIN
- RIGHT JOIN
- FULL OUTER JOIN
- CROSS JOIN

**Po pracy:**
- 30 zapyta≈Ñ z JOIN-ami
- Z≈Ço≈ºone raporty (3+ tabele)

**Przyk≈Çady:**
```sql
-- Wszystkie zam√≥wienia z danymi klient√≥w i produkt√≥w
SELECT
    z.id,
    k.email,
    k.imie + ' ' + k.nazwisko as klient,
    p.nazwa as produkt,
    pz.ilosc,
    pz.cena_jednostkowa,
    (pz.ilosc * pz.cena_jednostkowa) as wartosc
FROM zamowienia z
INNER JOIN klienci k ON z.klient_id = k.id
INNER JOIN pozycje_zamowien pz ON z.id = pz.zamowienie_id
INNER JOIN produkty p ON pz.produkt_id = p.id
ORDER BY z.data_zamowienia DESC;

-- Klienci bez zam√≥wie≈Ñ (LEFT JOIN)
SELECT k.email, k.imie, k.nazwisko
FROM klienci k
LEFT JOIN zamowienia z ON k.id = z.klient_id
WHERE z.id IS NULL;
```

**Weryfikacja:**
- [ ] Rozumiem INNER vs LEFT JOIN
- [ ] Potrafiƒô ≈ÇƒÖczyƒá 3+ tabele

---

### Tydzie≈Ñ 13 (3-9 Marca): Transakcje SQL

**W pracy:**
- BEGIN TRANSACTION
- COMMIT
- ROLLBACK
- Atomowo≈õƒá operacji

**Po pracy:**
- System zam√≥wie≈Ñ z transakcjami
- Testowanie b≈Çƒôd√≥w i ROLLBACK

**Przyk≈Çad:**
```sql
BEGIN TRANSACTION;

-- Sprawd≈∫ stan magazynowy
DECLARE @stan INT;
SELECT @stan = ilosc FROM produkty WHERE id = 1;

IF @stan >= 5
BEGIN
    -- Dodaj zam√≥wienie
    INSERT INTO zamowienia (klient_id, wartosc_total)
    VALUES (1, 500);

    -- Zmniejsz stan
    UPDATE produkty
    SET ilosc = ilosc - 5
    WHERE id = 1;

    COMMIT; -- Zatwierd≈∫
    PRINT 'Zam√≥wienie z≈Ço≈ºone!';
END
ELSE
BEGIN
    ROLLBACK; -- Wycofaj
    PRINT 'NiewystarczajƒÖcy stan!';
END
```

**Weryfikacja:**
- [ ] Rozumiem transakcje
- [ ] Potrafiƒô COMMIT/ROLLBACK

---

### Tydzie≈Ñ 14 (10-16 Marca): Azure SQL Database

**Cel:** Migracja z lokalnego SQL Server do Azure

**Dzie≈Ñ 1-2: Utworzenie Azure SQL Database**
- [ ] Rejestracja Azure (student account - darmowe credits!)
- [ ] Utworzenie Resource Group
- [ ] Utworzenie Azure SQL Server
- [ ] Utworzenie Azure SQL Database (Basic tier)
- [ ] Konfiguracja firewalla (dodaj swoje IP)

**Dzie≈Ñ 3-4: Migracja danych**
- [ ] Export lokalnej bazy do .bacpac
- [ ] Import do Azure SQL Database
- [ ] Po≈ÇƒÖczenie przez SSMS
- [ ] Sprawdzenie czy wszystko dzia≈Ça

**Dzie≈Ñ 5-7: R√≥≈ºnice Azure SQL vs SQL Server**
- [ ] Connection string (format Azure)
- [ ] Authentication (Azure AD vs SQL)
- [ ] Pricing tiers (DTU vs vCore)
- [ ] Backup i restore w Azure
- [ ] Monitoring (Azure Portal)

**PROJEKT KO≈ÉCA LUTEGO:**

**System Sklepu v2.0 - z Azure SQL Database**
- Przepisz projekt z Stycznia (Pure Python) na SQL
- Wszystkie dane w Azure SQL Database (nie s≈Çowniki!)
- Python jako frontend (menu, walidacja)
- SQL jako backend (wszystkie operacje CRUD)
- pyodbc do po≈ÇƒÖczenia

**Weryfikacja ko≈Ñca Lutego:**
- [ ] Azure SQL Database skonfigurowana
- [ ] Dane zmigrowane z lokalnego SQL
- [ ] System Sklepu v2.0 dzia≈Ça z Azure SQL
- [ ] Rozumiem r√≥≈ºnice Azure vs lokalny SQL

---

## MARZEC 2026 - OOP + pyodbc + Architektura

**Cel:** Programowanie obiektowe i integracja Python-SQL

**Czas:** 31 dni √ó 3.5h = 108.5 godzin

### Tydzie≈Ñ 15 (17-23 Marca): Klasy i Obiekty

**Dzie≈Ñ 1-3: Podstawy OOP**
```python
class Product:
    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity

    def display(self):
        print(f"{self.name}: {self.price} z≈Ç (stan: {self.quantity})")

    def update_quantity(self, amount):
        self.quantity += amount

# U≈ºycie
laptop = Product("Laptop", 2500, 10)
laptop.display()
laptop.update_quantity(-2)
```

**Dzie≈Ñ 4-7: Klasy dla systemu sklepu**
- [ ] Klasa `Product`
- [ ] Klasa `Customer`
- [ ] Klasa `Order`
- [ ] Klasa `OrderItem`
- [ ] Metody: `__str__`, `__repr__`
- [ ] Gettery i settery (@property)

**Weryfikacja:**
- [ ] Rozumiem klasƒô vs obiekt
- [ ] Potrafiƒô `__init__`
- [ ] Rozumiem self

---

### Tydzie≈Ñ 16 (24-30 Marca): pyodbc - Python + Azure SQL

**Dzie≈Ñ 1-2: Instalacja i po≈ÇƒÖczenie**
```bash
pip install pyodbc
```

```python
import pyodbc

# Connection string dla Azure SQL
server = 'twoj-serwer.database.windows.net'
database = 'SklepDB'
username = 'admin'
password = 'TwojeHaslo123!'

conn_string = (
    f'DRIVER={{ODBC Driver 17 for SQL Server}};'
    f'SERVER={server};'
    f'DATABASE={database};'
    f'UID={username};'
    f'PWD={password}'
)

# Po≈ÇƒÖczenie
conn = pyodbc.connect(conn_string)
cursor = conn.cursor()

# SELECT
cursor.execute("SELECT * FROM produkty")
for row in cursor.fetchall():
    print(row)

# INSERT (WA≈ªNE: parametry!)
cursor.execute("""
    INSERT INTO produkty (nazwa, cena, ilosc)
    VALUES (?, ?, ?)
""", ('Laptop', 2500, 10))
conn.commit()

# Zamkniƒôcie
cursor.close()
conn.close()
```

**Dzie≈Ñ 3-7: Klasa DatabaseManager**
```python
class DatabaseManager:
    def __init__(self, conn_string):
        self.conn_string = conn_string
        self.conn = None

    def connect(self):
        self.conn = pyodbc.connect(self.conn_string)

    def disconnect(self):
        if self.conn:
            self.conn.close()

    def execute_query(self, query, params=None):
        cursor = self.conn.cursor()
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        return cursor.fetchall()

    def execute_non_query(self, query, params=None):
        cursor = self.conn.cursor()
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        self.conn.commit()
```

**Weryfikacja:**
- [ ] pyodbc dzia≈Ça
- [ ] Po≈ÇƒÖczenie z Azure SQL OK
- [ ] Potrafiƒô SELECT, INSERT z parametrami

---

### Tydzie≈Ñ 17 (31 Marca - 6 Kwietnia): Architektura Warstwowa

**Cel:** Separacja Backend (SQL) od Frontend (Python menu)

**Struktura:**
```
sklep_v3/
‚îú‚îÄ‚îÄ main.py                # Frontend - menu
‚îú‚îÄ‚îÄ backend/
‚îÇ   ‚îú‚îÄ‚îÄ database_manager.py
‚îÇ   ‚îú‚îÄ‚îÄ product_repository.py
‚îÇ   ‚îú‚îÄ‚îÄ customer_repository.py
‚îÇ   ‚îî‚îÄ‚îÄ order_repository.py
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ product.py
‚îÇ   ‚îú‚îÄ‚îÄ customer.py
‚îÇ   ‚îî‚îÄ‚îÄ order.py
‚îú‚îÄ‚îÄ config.py
‚îî‚îÄ‚îÄ requirements.txt
```

**Przyk≈Çad Repository Pattern:**
```python
# product_repository.py
class ProductRepository:
    def __init__(self, db_manager):
        self.db = db_manager

    def get_all(self):
        query = "SELECT * FROM produkty"
        rows = self.db.execute_query(query)
        return [Product.from_db_row(row) for row in rows]

    def get_by_id(self, product_id):
        query = "SELECT * FROM produkty WHERE id = ?"
        rows = self.db.execute_query(query, (product_id,))
        if rows:
            return Product.from_db_row(rows[0])
        return None

    def create(self, product):
        query = """
            INSERT INTO produkty (nazwa, cena, ilosc, kategoria)
            VALUES (?, ?, ?, ?)
        """
        self.db.execute_non_query(query, (
            product.name,
            product.price,
            product.quantity,
            product.category
        ))

    def update(self, product):
        query = """
            UPDATE produkty
            SET nazwa=?, cena=?, ilosc=?, kategoria=?
            WHERE id=?
        """
        self.db.execute_non_query(query, (
            product.name,
            product.price,
            product.quantity,
            product.category,
            product.id
        ))

    def delete(self, product_id):
        query = "DELETE FROM produkty WHERE id=?"
        self.db.execute_non_query(query, (product_id,))
```

**Weryfikacja:**
- [ ] Rozumiem separacjƒô Backend/Frontend
- [ ] Repository Pattern dzia≈Ça
- [ ] Kod modularny

---

### Tydzie≈Ñ 18 (7-13 Kwietnia): PROJEKT MIESIƒÑCA

**System Sklepu v3.0 - OOP + Azure SQL**

**Wymagania:**
- Klasy: Product, Customer, Order, OrderItem
- Repositories: ProductRepository, CustomerRepository, OrderRepository
- DatabaseManager (singleton pattern)
- Menu u≈ºytkownika (jak dotychczas)
- Wszystkie operacje przez repositories
- Transakcje przy sk≈Çadaniu zam√≥wienia:
  ```python
  def create_order(self, customer_id, items):
      try:
          self.db.conn.autocommit = False  # Start transaction

          # Insert zam√≥wienie
          order_id = self.insert_order(customer_id)

          # Insert pozycje + update stany
          for item in items:
              self.insert_order_item(order_id, item)
              self.update_product_stock(item.product_id, -item.quantity)

          self.db.conn.commit()  # Commit
          return True, "Zam√≥wienie z≈Ço≈ºone!"
      except Exception as e:
          self.db.conn.rollback()  # Rollback
          return False, f"B≈ÇƒÖd: {e}"
      finally:
          self.db.conn.autocommit = True
  ```

**Weryfikacja ko≈Ñca Marca:**
- [ ] System v3.0 w pe≈Çni funkcjonalny
- [ ] OOP + Azure SQL dzia≈Ça
- [ ] Transakcje poprawne
- [ ] Kod ~800 linii

---

## KWIECIE≈É 2026 - pandas + Excel + Azure Blob Storage

**Cel:** Raporty w Excel + storage w chmurze

**Czas:** 30 dni √ó 3.5h = 105 godzin

### Tydzie≈Ñ 19 (14-20 Kwietnia): pandas - Podstawy

**Dzie≈Ñ 1-3: DataFrame**
```python
import pandas as pd
import pyodbc

# Po≈ÇƒÖczenie
conn = pyodbc.connect(conn_string)

# SQL ‚Üí DataFrame
query = "SELECT * FROM produkty"
df = pd.read_sql(query, conn)

# Podstawowe operacje
print(df.head())        # Pierwsze 5 wierszy
print(df.info())        # Info o DataFrame
print(df.describe())    # Statystyki

# Filtrowanie
drogie = df[df['cena'] > 1000]

# Sortowanie
sorted_df = df.sort_values('cena', ascending=False)

# Nowa kolumna
df['wartosc'] = df['cena'] * df['ilosc']
```

**Dzie≈Ñ 4-7: Agregacje i GroupBy**
```python
# GroupBy
by_category = df.groupby('kategoria').agg({
    'cena': 'mean',
    'ilosc': 'sum',
    'nazwa': 'count'
})

# Merge (jak JOIN)
df_orders = pd.read_sql("SELECT * FROM zamowienia", conn)
df_customers = pd.read_sql("SELECT * FROM klienci", conn)

merged = df_orders.merge(
    df_customers,
    left_on='klient_id',
    right_on='id',
    how='inner'
)
```

**Weryfikacja:**
- [ ] Rozumiem DataFrame
- [ ] Potrafiƒô pd.read_sql
- [ ] GroupBy i merge dzia≈ÇajƒÖ

---

### Tydzie≈Ñ 20 (21-27 Kwietnia): Excel zaawansowany + pandas

**Dzie≈Ñ 1-3: pandas ‚Üí Excel**
```python
# Prosty eksport
df.to_excel('produkty.xlsx', index=False)

# Z formatowaniem (openpyxl)
from openpyxl import load_workbook
from openpyxl.styles import Font, PatternFill

# Zapis
df.to_excel('raport.xlsx', index=False, engine='openpyxl')

# Formatowanie
wb = load_workbook('raport.xlsx')
ws = wb.active

# Nag≈Ç√≥wki
for cell in ws[1]:
    cell.font = Font(bold=True, color="FFFFFF")
    cell.fill = PatternFill(start_color="4472C4", fill_type="solid")

# Auto-width
for column in ws.columns:
    max_length = max(len(str(cell.value)) for cell in column)
    ws.column_dimensions[column[0].column_letter].width = max_length + 2

wb.save('raport.xlsx')
```

**Dzie≈Ñ 4-7: Multiple sheets + wykresy**
```python
# Multiple sheets
with pd.ExcelWriter('raporty.xlsx', engine='openpyxl') as writer:
    df_products.to_excel(writer, sheet_name='Produkty', index=False)
    df_customers.to_excel(writer, sheet_name='Klienci', index=False)
    df_orders.to_excel(writer, sheet_name='Zam√≥wienia', index=False)

# Wykresy (opcjonalnie)
from openpyxl.chart import BarChart, Reference

wb = load_workbook('raporty.xlsx')
ws = wb['Produkty']

chart = BarChart()
chart.title = "Produkty wg kategorii"
data = Reference(ws, min_col=2, min_row=1, max_row=10)
chart.add_data(data, titles_from_data=True)
ws.add_chart(chart, "E5")

wb.save('raporty.xlsx')
```

**Weryfikacja:**
- [ ] Eksport do Excel z formatowaniem
- [ ] Multiple sheets dzia≈Ça

---

### Tydzie≈Ñ 21 (28 Kwietnia - 4 Maja): Azure Blob Storage

**Cel:** Przechowywanie plik√≥w Excel w chmurze Azure

**Dzie≈Ñ 1-2: Utworzenie Storage Account**
- [ ] Azure Portal ‚Üí Create Storage Account
- [ ] Utworzenie kontenera "raporty"
- [ ] Pobranie connection string

**Dzie≈Ñ 3-5: Upload/Download plik√≥w**
```bash
pip install azure-storage-blob
```

```python
from azure.storage.blob import BlobServiceClient

# Connection string
conn_str = "DefaultEndpointsProtocol=https;..."
blob_service = BlobServiceClient.from_connection_string(conn_str)

# Upload
with open("raport.xlsx", "rb") as data:
    blob_client = blob_service.get_blob_client(
        container="raporty",
        blob="raport_2026-04-30.xlsx"
    )
    blob_client.upload_blob(data, overwrite=True)

# Download
blob_client = blob_service.get_blob_client(
    container="raporty",
    blob="raport_2026-04-30.xlsx"
)
with open("downloaded.xlsx", "wb") as download_file:
    download_file.write(blob_client.download_blob().readall())

# Lista plik√≥w
container_client = blob_service.get_container_client("raporty")
for blob in container_client.list_blobs():
    print(blob.name)
```

**Dzie≈Ñ 6-7: Integracja z systemem**
- [ ] Funkcja `upload_report_to_azure(filename)`
- [ ] Funkcja `download_report_from_azure(blob_name)`
- [ ] Lista raport√≥w w Azure
- [ ] Menu: "Prze≈õlij raport do Azure"

**Weryfikacja:**
- [ ] Azure Blob Storage skonfigurowany
- [ ] Upload/download dzia≈Ça
- [ ] System zapisuje raporty w chmurze

---

### Tydzie≈Ñ 22 (5-11 Maja): PROJEKT MIESIƒÑCA

**System Sklepu v4.0 - Raporty w Excel + Azure**

**Wymagania:**
1. **5 raport√≥w Excel:**
   - Raport produkt√≥w (z warto≈õciƒÖ magazynu)
   - Raport zam√≥wie≈Ñ (ostatnie 30 dni)
   - Raport klient√≥w (suma zam√≥wie≈Ñ per klient)
   - Top 10 produkt√≥w (najczƒô≈õciej kupowane)
   - Analiza sprzeda≈ºy per kategoria

2. **Ka≈ºdy raport:**
   - Formatowanie (nag≈Ç√≥wki, kolory, auto-width)
   - Timestamp w nazwie pliku
   - Automatyczny upload do Azure Blob Storage
   - Podsumowanie (SUM, AVG na ko≈Ñcu)

3. **Menu:**
   - "Generuj raport produkt√≥w"
   - "Generuj raport zam√≥wie≈Ñ"
   - ... (dla ka≈ºdego)
   - "Lista raport√≥w w Azure"
   - "Pobierz raport z Azure"

**Weryfikacja ko≈Ñca Kwietnia:**
- [ ] 5 raport√≥w dzia≈Ça
- [ ] Eksport do Excel z formatowaniem
- [ ] Upload do Azure automatyczny
- [ ] System v4.0 gotowy

---

## MAJ 2026 - GUI Tkinter + Integracja

**Cel:** Graficzny interfejs u≈ºytkownika

**Czas:** 31 dni √ó 3.5h = 108.5 godzin

### Tydzie≈Ñ 23 (12-18 Maja): Tkinter - Podstawy

**Dzie≈Ñ 1-3: Pierwsze okno**
```python
import tkinter as tk

# Okno
root = tk.Tk()
root.title("Moja aplikacja")
root.geometry("800x600")

# Label
label = tk.Label(root, text="Hello World", font=("Arial", 16))
label.pack(pady=20)

# Button
def on_click():
    label.config(text="Klikniƒôto!")

button = tk.Button(root, text="Kliknij mnie", command=on_click)
button.pack()

# Entry
entry = tk.Entry(root, width=30)
entry.pack(pady=10)

# Uruchomienie
root.mainloop()
```

**Dzie≈Ñ 4-7: Wiƒôcej widget√≥w**
- [ ] Listbox
- [ ] Combobox (ttk)
- [ ] Spinbox
- [ ] Checkbutton
- [ ] Radiobutton
- [ ] Text (wieloliniowy)
- [ ] Scrollbar

**Projekt:** Kalkulator GUI

**Weryfikacja:**
- [ ] Rozumiem widgety
- [ ] Potrafiƒô tworzyƒá okna

---

### Tydzie≈Ñ 24 (19-25 Maja): Layout i Zak≈Çadki

**Dzie≈Ñ 1-3: Grid layout**
```python
# Grid - uk≈Çad tabelaryczny
label1 = tk.Label(root, text="Nazwa:")
label1.grid(row=0, column=0, sticky=tk.W, padx=10, pady=5)

entry1 = tk.Entry(root, width=30)
entry1.grid(row=0, column=1, padx=10, pady=5)

label2 = tk.Label(root, text="Cena:")
label2.grid(row=1, column=0, sticky=tk.W, padx=10, pady=5)

entry2 = tk.Entry(root, width=30)
entry2.grid(row=1, column=1, padx=10, pady=5)
```

**Dzie≈Ñ 4-7: Notebook (zak≈Çadki)**
```python
from tkinter import ttk

notebook = ttk.Notebook(root)
notebook.pack(fill='both', expand=True)

# Zak≈Çadka 1
tab1 = ttk.Frame(notebook)
notebook.add(tab1, text="Produkty")

# Zak≈Çadka 2
tab2 = ttk.Frame(notebook)
notebook.add(tab2, text="Klienci")

# Zak≈Çadka 3
tab3 = ttk.Frame(notebook)
notebook.add(tab3, text="Zam√≥wienia")
```

**Weryfikacja:**
- [ ] Grid layout dzia≈Ça
- [ ] Notebook (zak≈Çadki) OK

---

### Tydzie≈Ñ 25 (26 Maja - 1 Czerwca): Integracja GUI + Backend

**Dzie≈Ñ 1-3: Po≈ÇƒÖczenie z bazƒÖ**
```python
class ShopGUI:
    def __init__(self):
        self.root = tk.Tk()
        self.root.title("System Sklepu")

        # Backend
        self.db = DatabaseManager(conn_string)
        self.db.connect()
        self.product_repo = ProductRepository(self.db)

        self.create_gui()

    def create_gui(self):
        # Notebook
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill='both', expand=True)

        # Zak≈Çadki
        self.create_products_tab(notebook)
        self.create_customers_tab(notebook)
        self.create_orders_tab(notebook)

    def create_products_tab(self, notebook):
        tab = ttk.Frame(notebook)
        notebook.add(tab, text="Produkty")

        # Listbox z produktami
        self.products_listbox = tk.Listbox(tab, width=50, height=20)
        self.products_listbox.pack(side=tk.LEFT, padx=10, pady=10)

        # Przyciski
        btn_frame = ttk.Frame(tab)
        btn_frame.pack(side=tk.LEFT, padx=10, pady=10)

        ttk.Button(btn_frame, text="Dodaj produkt",
                   command=self.add_product).pack(pady=5)
        ttk.Button(btn_frame, text="Edytuj produkt",
                   command=self.edit_product).pack(pady=5)
        ttk.Button(btn_frame, text="Usu≈Ñ produkt",
                   command=self.delete_product).pack(pady=5)
        ttk.Button(btn_frame, text="Od≈õwie≈º",
                   command=self.load_products).pack(pady=5)

        # ≈Åadowanie produkt√≥w
        self.load_products()

    def load_products(self):
        self.products_listbox.delete(0, tk.END)
        products = self.product_repo.get_all()
        for p in products:
            self.products_listbox.insert(tk.END,
                f"{p.name} - {p.price} z≈Ç (stan: {p.quantity})")

    def add_product(self):
        # Nowe okno (Toplevel)
        dialog = tk.Toplevel(self.root)
        dialog.title("Dodaj produkt")

        # Pola formularza
        tk.Label(dialog, text="Nazwa:").grid(row=0, column=0)
        name_entry = tk.Entry(dialog)
        name_entry.grid(row=0, column=1)

        tk.Label(dialog, text="Cena:").grid(row=1, column=0)
        price_entry = tk.Entry(dialog)
        price_entry.grid(row=1, column=1)

        # ... etc

        def save():
            product = Product(
                name=name_entry.get(),
                price=float(price_entry.get()),
                # ...
            )
            self.product_repo.create(product)
            self.load_products()
            dialog.destroy()

        tk.Button(dialog, text="Zapisz", command=save).grid(row=5, column=0)

    def run(self):
        self.root.mainloop()

# Uruchomienie
if __name__ == "__main__":
    app = ShopGUI()
    app.run()
```

**Dzie≈Ñ 4-7: Wszystkie zak≈Çadki**
- [ ] Zak≈Çadka Produkty (gotowa)
- [ ] Zak≈Çadka Klienci (analogicznie)
- [ ] Zak≈Çadka Zam√≥wienia (formularz + lista)
- [ ] Zak≈Çadka Raporty (przyciski generowania)

**Weryfikacja:**
- [ ] GUI po≈ÇƒÖczone z Azure SQL
- [ ] CRUD przez GUI dzia≈Ça
- [ ] Wszystkie zak≈Çadki OK

---

### Tydzie≈Ñ 26 (2-8 Czerwca): PROJEKT MIESIƒÑCA

**System Sklepu v5.0 - FINA≈Å (GUI + Azure SQL + Blob Storage)**

**Wymagania:**

**4 zak≈Çadki:**
1. **Produkty:**
   - Listbox z produktami
   - Przyciski: Dodaj, Edytuj, Usu≈Ñ, Od≈õwie≈º
   - Dialog do dodawania/edycji (Grid layout)
   - Walidacja (try-except + messagebox)

2. **Klienci:**
   - Analogicznie jak Produkty
   - Walidacja email (regex)

3. **Zam√≥wienia:**
   - Combobox wyboru klienta
   - Listbox produkt√≥w (multi-select)
   - Spinbox ilo≈õci
   - Przycisk "Z≈Ç√≥≈º zam√≥wienie"
   - Transakcja SQL (commit/rollback)
   - Messagebox z potwierdzeniem

4. **Raporty:**
   - 5 przycisk√≥w (dla ka≈ºdego raportu)
   - Generowanie Excel
   - Upload do Azure Blob
   - Messagebox: "Raport wygenerowany i przes≈Çany do Azure"
   - Przycisk "Lista raport√≥w w Azure"
   - Przycisk "Pobierz raport"

**Technologie:**
- Frontend: Tkinter (4 zak≈Çadki)
- Backend: OOP (repositories)
- Database: Azure SQL Database
- Storage: Azure Blob Storage
- Raporty: pandas + openpyxl

**Wymagania techniczne:**
- ~1200 linii kodu
- Try-except + messagebox dla b≈Çƒôd√≥w
- PEP 8 compliant
- Docstringi

**Weryfikacja ko≈Ñca Maja:**
- [ ] System v5.0 w 100% funkcjonalny
- [ ] GUI profesjonalny
- [ ] Azure SQL + Blob dzia≈ÇajƒÖ
- [ ] **GOTOWY NA DEMO!**

---

## CZERWIEC 2026 - Azure Cloud (Functions, App Service)

**Cel:** Deployment aplikacji w Azure

**Czas:** 30 dni √ó 3.5h = 105 godzin

### Tydzie≈Ñ 27 (9-15 Czerwca): Azure Functions

**Dzie≈Ñ 1-3: Pierwsza Function**
- [ ] Utworzenie Function App w Azure
- [ ] Pierwsza HTTP triggered function (Python)
- [ ] Testowanie w przeglƒÖdarce

**Przyk≈Çad:**
```python
# __init__.py
import logging
import azure.functions as func

def main(req: func.HttpRequest) -> func.HttpResponse:
    logging.info('Python HTTP trigger function.')

    name = req.params.get('name')
    if not name:
        try:
            req_body = req.get_json()
        except ValueError:
            pass
        else:
            name = req_body.get('name')

    if name:
        return func.HttpResponse(
            f"Hello, {name}!",
            status_code=200
        )
    else:
        return func.HttpResponse(
            "Please pass a name",
            status_code=400
        )
```

**Dzie≈Ñ 4-7: Functions dla systemu**
- [ ] Function: GenerateProductReport (HTTP trigger)
- [ ] Function: GetProducts (HTTP trigger)
- [ ] Function: CreateOrder (HTTP trigger)
- [ ] Timer trigger: Auto-backup co 24h

**Weryfikacja:**
- [ ] Azure Functions dzia≈Ça
- [ ] HTTP triggers OK
- [ ] Timer trigger dzia≈Ça

---

### Tydzie≈Ñ 28 (16-22 Czerwca): Azure App Service

**Dzie≈Ñ 1-3: Flask API**
```python
# app.py
from flask import Flask, jsonify, request
import pyodbc

app = Flask(__name__)

# Connection string z environment variables
conn_string = os.environ.get('AZURE_SQL_CONNECTION_STRING')

@app.route('/api/products', methods=['GET'])
def get_products():
    conn = pyodbc.connect(conn_string)
    cursor = conn.cursor()
    cursor.execute("SELECT * FROM produkty")
    products = []
    for row in cursor.fetchall():
        products.append({
            'id': row.id,
            'name': row.nazwa,
            'price': float(row.cena),
            'quantity': row.ilosc
        })
    conn.close()
    return jsonify(products)

@app.route('/api/products', methods=['POST'])
def create_product():
    data = request.get_json()
    conn = pyodbc.connect(conn_string)
    cursor = conn.cursor()
    cursor.execute("""
        INSERT INTO produkty (nazwa, cena, ilosc)
        VALUES (?, ?, ?)
    """, (data['name'], data['price'], data['quantity']))
    conn.commit()
    conn.close()
    return jsonify({'message': 'Product created'}), 201

if __name__ == '__main__':
    app.run()
```

**Dzie≈Ñ 4-7: Deployment do Azure App Service**
- [ ] Utworzenie Web App
- [ ] Deploy przez VS Code lub Azure CLI
- [ ] Konfiguracja environment variables
- [ ] Testowanie API

**Weryfikacja:**
- [ ] Flask API dzia≈Ça lokalnie
- [ ] Deployment do Azure OK
- [ ] API dostƒôpne z internetu

---

### Tydzie≈Ñ 29 (23-29 Czerwca): Monitoring i Security

**Dzie≈Ñ 1-3: Application Insights**
- [ ] Dodanie Application Insights do Function App
- [ ] Monitoring log√≥w
- [ ] Performance metrics
- [ ] Custom events

**Dzie≈Ñ 4-7: Security**
- [ ] Azure Key Vault (przechowywanie secrets)
- [ ] Managed Identity
- [ ] Connection strings z Key Vault
- [ ] HTTPS tylko (wymuszenie)

**Weryfikacja:**
- [ ] Monitoring dzia≈Ça
- [ ] Secrets w Key Vault
- [ ] Security best practices

---

### Tydzie≈Ñ 30 (30 Czerwca - 6 Lipca): PROJEKT MIESIƒÑCA

**System Sklepu v6.0 - Cloud Native**

**Architektura:**
```
Frontend (Tkinter Desktop App)
    ‚Üì (HTTP requests)
Azure App Service (Flask REST API)
    ‚Üì (pyodbc)
Azure SQL Database
    ‚Üì (backup)
Azure Blob Storage
    ‚Üë (monitoring)
Application Insights
```

**Komponenty:**

1. **Flask REST API** (Azure App Service):
   - Endpoints: GET/POST/PUT/DELETE dla produkt√≥w, klient√≥w, zam√≥wie≈Ñ
   - Autoryzacja (API key)
   - Error handling
   - Logging

2. **Tkinter Client** (Desktop):
   - Zamiast bezpo≈õredniego po≈ÇƒÖczenia z SQL ‚Üí wywo≈Çania HTTP do API
   - Biblioteka `requests`
   - Wszystkie funkcje jak v5.0, ale przez API

3. **Azure Functions** (background tasks):
   - Daily backup (timer trigger)
   - Email notifications (queue trigger)
   - Report generation (HTTP trigger)

4. **Monitoring:**
   - Application Insights
   - Alerty (email gdy b≈ÇƒÖd)

**Weryfikacja ko≈Ñca Czerwca:**
- [ ] System v6.0 Cloud Native dzia≈Ça
- [ ] API w Azure App Service
- [ ] Desktop app przez API
- [ ] Azure Functions dzia≈ÇajƒÖ
- [ ] Monitoring OK

---

## LIPIEC 2026 - Projekt Fina≈Çowy (Praca In≈ºynierska)

**Cel:** Doko≈Ñczyƒá i dopracowaƒá system na obronƒô

**Czas:** 31 dni √ó 4h = 124 godziny

### Tydzie≈Ñ 31 (7-13 Lipca): Dodatkowe funkcje

**Rozszerzenia:**
- [ ] Oracle Database (opcjonalnie - read-only)
- [ ] Databricks (podstawy - analityka)
- [ ] Power BI (wizualizacja raport√≥w)
- [ ] Azure Logic Apps (automatyzacja workflow)
- [ ] Azure DevOps (CI/CD pipeline)

---

### Tydzie≈Ñ 32-33 (14-27 Lipca): Dokumentacja

**Wymagania:**

1. **README.md** (10+ stron):
   - Opis projektu
   - Architektura (diagramy!)
   - Technologie u≈ºyte
   - Instalacja (lokalna + Azure)
   - Konfiguracja
   - U≈ºycie (screenshots!)
   - API documentation
   - Troubleshooting

2. **USER_GUIDE.md**:
   - Instrukcja dla u≈ºytkownika ko≈Ñcowego
   - Screenshots ka≈ºdej funkcji
   - FAQ

3. **ARCHITECTURE.md**:
   - Szczeg√≥≈Çowa architektura
   - Diagramy (draw.io / Lucidchart)
   - Database schema
   - API endpoints
   - Azure resources

4. **DEPLOYMENT.md**:
   - Krok po kroku deployment do Azure
   - Konfiguracja ≈õrodowiska
   - Environment variables
   - Security checklist

---

### Tydzie≈Ñ 34 (28 Lipca - 3 Sierpnia): Testy i Optymalizacja

**Testy:**
- [ ] Unit testy (pytest)
- [ ] Integration testy
- [ ] Load testing (Azure Load Testing)
- [ ] Security testing (OWASP)

**Optymalizacja:**
- [ ] Indeksy w bazie danych
- [ ] Caching (Azure Cache for Redis - opcjonalnie)
- [ ] Query optimization
- [ ] Code refactoring

---

## SIERPIE≈É 2026 - Finalizacja

**Cel:** Prezentacja i obrona

**Tydzie≈Ñ 35-36 (4-17 Sierpnia): Prezentacja**

**Slajdy (20-25):**
1. Tytu≈Ç + autor
2. Problem biznesowy
3. Cel pracy
4. Technologie
5-8. Architektura (4 slajdy z diagramami)
9-12. Funkcjonalno≈õci (screenshots)
13-15. Azure Cloud (Functions, App Service, SQL, Blob)
16-17. Demo live
18. Wyniki (performance metrics)
19. Wnioski
20. Kierunki rozwoju (Oracle, Databricks, AI/ML)
21. Bibliografia
22. Pytania

**Przygotowanie demo:**
- [ ] Video demo (5 minut)
- [ ] Live demo (plan B je≈õli internet nie dzia≈Ça)
- [ ] Backup prezentacji

**Tydzie≈Ñ 37 (18-24 Sierpnia): Rehearsal**
- [ ] Pr√≥ba prezentacji (3√ó)
- [ ] Timing (20 minut maks)
- [ ] Odpowiedzi na mo≈ºliwe pytania
- [ ] Feedback od koleg√≥w

---

## WRZESIE≈É 2026 - Obrona!

**Tydzie≈Ñ 38+ (1-30 Wrze≈õnia):**
- [ ] Ostatnie poprawki
- [ ] Druk pracy
- [ ] Z≈Ço≈ºenie pracy
- [ ] **OBRONA PRACY IN≈ªYNIERSKIEJ** üéì

---

## Podsumowanie - Co osiƒÖgniesz

### Projekty w portfolio:

1. ‚úÖ Lista zakup√≥w (Grudzie≈Ñ - DONE)
2. ‚úÖ S≈Çownik produkt√≥w (Grudzie≈Ñ - DONE)
3. System Biblioteki v1.0 (Grudzie≈Ñ)
4. System Sklepu v1.0 - Pure Python (Stycze≈Ñ)
5. System Sklepu v2.0 - Azure SQL (Luty)
6. System Sklepu v3.0 - OOP + Azure (Marzec)
7. System Sklepu v4.0 - Excel + Blob (Kwiecie≈Ñ)
8. System Sklepu v5.0 - GUI Tkinter (Maj)
9. System Sklepu v6.0 - Cloud Native (Czerwiec)
10. **PRACA IN≈ªYNIERSKA** - Finalna wersja (Lipiec-Sierpie≈Ñ)

### Technologie opanowane:

**Python:**
- Fundamenty (listy, s≈Çowniki, funkcje, klasy)
- JSON, datetime, regex
- List comprehensions, lambda
- Modu≈Çy, try-except zaawansowany
- openpyxl, pandas
- Tkinter (GUI)
- Flask (REST API)
- requests (HTTP client)
- pytest (testy)

**SQL:**
- SQL Server (lokalny)
- Azure SQL Database
- CREATE, INSERT, SELECT, UPDATE, DELETE
- JOIN-y, agregacje, GROUP BY
- Transakcje (COMMIT/ROLLBACK)
- Indeksy, optymalizacja

**Azure Cloud:**
- Azure SQL Database
- Azure Blob Storage
- Azure Functions
- Azure App Service
- Azure Key Vault
- Application Insights
- (opcjonalnie) Oracle, Databricks

**Narzƒôdzia:**
- Git/GitHub
- VS Code
- Azure Portal
- SSMS
- Postman (API testing)

### Statystyki:

- **Godziny nauki:** ~900h (9 miesiƒôcy √ó 100h/miesiƒÖc)
- **Linie kodu:** ~15,000+
- **Commit√≥w GitHub:** 200+
- **Dokumentacja:** 100+ stron
- **Prezentacja:** 25 slajd√≥w

---

## Nastƒôpne kroki - CO ROBIƒÜ TERAZ

### DZI≈ö - 17 Grudnia (wtorek):
**Czas dostƒôpny:** ~3-4h

**Priorytet 1: Doko≈Ñcz `show_products()` i `sort_products()`**
- [ ] Widzƒô ≈ºe zaczƒÖ≈Çe≈õ `show_products()` - doko≈Ñcz to!
- [ ] Widzƒô lambda w `sort_products()` - napraw b≈ÇƒÖd (linia 76: `key = lambda` jest niepoprawne)
  - Powinno byƒá: `key=lambda item: item[0]` (sortowanie po nazwie)
  - Lub: `key=lambda item: item[1]['cena']` (sortowanie po cenie)
- [ ] Testuj te 2 funkcje z r√≥≈ºnymi produktami

**Priorytet 2: Dodaj `edit_product()`**
- [ ] Funkcja do edycji produktu (zmiana ceny/ilo≈õci/kategorii)
- [ ] Walidacja jak w `add_product()`
- [ ] Testuj

**Je≈õli zostanie czas:**
- [ ] GitHub: Je≈õli nie masz repo - za≈Ç√≥≈º! (c:\projekty\nauka ‚Üí GitHub)
- [ ] Commit tego co masz

---

### 18-19 Grudnia (≈õroda-czwartek):
**~6-8h total**
- [ ] `filter_by_category()` - poka≈º tylko produkty z danej kategorii
- [ ] `find_max_price()` - znajd≈∫ najdro≈ºszy produkt
- [ ] `find_min_price()` - znajd≈∫ najta≈Ñszy produkt
- [ ] Wszystkie z walidacjƒÖ!

---

### 20-22 Grudnia (pt-nd WEEKEND):
**~4-6h total (mniej w weekend!)**
- [ ] `calculate_total_value()` - suma warto≈õci magazynu
- [ ] `low_stock_alert()` - produkty < 5 sztuk
- [ ] Review wszystkich funkcji
- [ ] Testy z r√≥≈ºnymi danymi
- [ ] Commit do GitHub

---

### 23 Grudnia (pn):
**~3h**
- [ ] Refactoring kodu
- [ ] Dodaj docstringi do wszystkich funkcji
- [ ] PEP 8 formatting
- [ ] Ostatni commit przed ≈õwiƒôtami

---

### 24-26 Grudnia (≈öWIƒòTA):
**Odpoczynek!** Lub max 1h/dzie≈Ñ je≈õli masz ochotƒô i czas

---

### 27-29 Grudnia (pt-nd):
**~6h total**
- [ ] Ostatnie poprawki s≈Çownika produkt√≥w
- [ ] Przygotowanie do nauki JSON (poczytaj o module `json`)
- [ ] Lista funkcji kt√≥re chcesz dodaƒá w przysz≈Ço≈õci

---

### 30-31 Grudnia (pn-wt):
**START Tygodnia 3: JSON!**
- [ ] Instalacja niczego nie trzeba - `json` to built-in
- [ ] Pierwszy zapis do JSON
- [ ] Pierwszy odczyt z JSON

**Szczeg√≥≈Çy w planie powy≈ºej (Tydzie≈Ñ 3)!**

---

**Powodzenia! Za 9 miesiƒôcy bƒôdziesz in≈ºynierem z pe≈Çnym systemem w Azure! üöÄ**
